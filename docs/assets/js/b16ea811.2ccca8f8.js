"use strict";(self.webpackChunk_docstack_docs=self.webpackChunk_docstack_docs||[]).push([[8650],{1184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},6297:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"architecture/data-model-triggers","title":"Triggers","description":"Abstract","source":"@site/docs/architecture/data-model-triggers.md","sourceDirName":"architecture","slug":"/architecture/data-model-triggers","permalink":"/docstack/docs/architecture/data-model-triggers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/architecture/data-model-triggers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Structure and propagation","permalink":"/docstack/docs/architecture/data-model-propagation"},"next":{"title":"Infrastructure","permalink":"/docstack/docs/architecture/infrastructure"}}');var s=t(4848),r=t(1184);const a={},o="Triggers",c={},d=[{value:"Abstract",id:"abstract",level:3},{value:"1. Design Philosophy",id:"1-design-philosophy",level:2},{value:"2. Core Component Architecture",id:"2-core-component-architecture",level:2},{value:"3. The Hydration Process",id:"3-the-hydration-process",level:2},{value:"4. Usage and Execution Flow",id:"4-usage-and-execution-flow",level:2},{value:"5. Security and Reliability",id:"5-security-and-reliability",level:2},{value:"6. Conclusion",id:"6-conclusion",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"triggers",children:"Triggers"})}),"\n",(0,s.jsx)(n.h3,{id:"abstract",children:"Abstract"}),"\n",(0,s.jsx)(n.p,{children:"This whitepaper presents the design and implementation of the Trigger class, a core component for a data-driven application architecture. By enabling the runtime hydration of executable logic from a declarative data model, the Trigger class provides a flexible and powerful mechanism for defining custom data validations, transformations, and business rules. This design promotes a highly decoupled system where application behavior can be defined and modified as data, without requiring a redeployment of the application code."}),"\n",(0,s.jsx)(n.h2,{id:"1-design-philosophy",children:"1. Design Philosophy"}),"\n",(0,s.jsx)(n.p,{children:"The Trigger class is built on three fundamental principles:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Declarative Behavior: Application logic is defined in a structured data format (TriggerModel), typically stored in a database alongside the data models they operate on. This transforms the application's behavior from being statically coded into a dynamic and configurable asset."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dynamic Hydration: The executable logic, represented as a string within the data model, is dynamically converted into a callable function at runtime. This allows for powerful, late-binding behavior."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Secure Dependency Injection: The dynamic function's execution environment is carefully sandboxed. Instead of using a global eval(), which has significant security risks, the Trigger class employs new Function() to create a function with an isolated scope. Critical dependencies (document, classObj, stack) are explicitly injected as function arguments, providing the developer with a powerful, yet controlled, execution context."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-core-component-architecture",children:"2. Core Component Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The Trigger class comprises two primary components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"model"})," (",(0,s.jsx)(n.strong,{children:"Input"}),'): An immutable data object (TriggerModel) that serves as the blueprint for the trigger. It contains a unique name, an order ("before" or "after") to define its execution timing, and the run field. The run field is the string representation of the function\'s body.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"run"})," (Output): The dynamically created, callable method. This function adheres to a strict signature, taking the target document as an argument and returning the updated document."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-the-hydration-process",children:"3. The Hydration Process"}),"\n",(0,s.jsx)(n.p,{children:"The core innovation of the Trigger class lies in its constructor, where the run method is hydrated:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The constructor receives a TriggerModel and a reference to the parent Class instance."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["It uses ",(0,s.jsx)(n.code,{children:"new Function('document', 'classObj', 'stack', ...)"})," to create a new function instance. The first three arguments (",(0,s.jsx)(n.code,{children:"document, classObj, stack"}),") explicitly declare the variables that will be available within the function's scope."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The body of the function is the developer-provided ",(0,s.jsx)(n.code,{children:"run"})," string."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The newly created function is assigned to the ",(0,s.jsx)(n.code,{children:"this.run"})," property of the Trigger instance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Comprehensive error handling is implemented to catch syntax errors or issues that may arise during this dynamic function creation."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This process ensures that the developer's logic can access the document being processed, the classObj for context, and the stack for interacting with the rest of the application's data layer, all without exposing the global scope."}),"\n",(0,s.jsx)(n.h2,{id:"4-usage-and-execution-flow",children:"4. Usage and Execution Flow"}),"\n",(0,s.jsx)(n.p,{children:"The Trigger class is designed for seamless integration into a data model layer. Its execute method is asynchronous by default, ensuring a consistent and predictable API for all consumers."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Data Definition"}),": A TriggerModel is defined and stored whithin its class data model. The run field can contain both synchronous and asynchronous JavaScript logic, including await expressions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Instantiation"}),": A parent Class instance, upon initialization or a change in its data model, creates a new Trigger instance for each corresponding TriggerModel."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution"}),': When a data operation is about to occur ("before") or has just completed ("after"), the Class instance calls the ',(0,s.jsx)(n.code,{children:"trigger.execute(document)"})," method. This method, in turn, calls the hydrated run function and awaits its completion. This ensures that any asynchronous operations (e.g., querying the database for related documents) are fully resolved before the flow continues."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": The run function's return value (the updated document) is awaited and then used by the Class to complete the data operation. This asynchronous-by-default design prevents race conditions and simplifies the calling code. The execute method also includes a safeguard to ensure a document is always returned, even if the run function does not explicitly do so."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach provides a robust and reliable execution model, making the Trigger class suitable for a wide range of data transformation and validation tasks, from simple field assignments to complex cross-document business rules."}),"\n",(0,s.jsx)(n.h2,{id:"5-security-and-reliability",children:"5. Security and Reliability"}),"\n",(0,s.jsxs)(n.p,{children:["The Trigger design acknowledges the inherent risks of executing dynamic code. By using ",(0,s.jsx)(n.code,{children:"new Function()"})," instead of eval(), the code runs in a ",(0,s.jsx)(n.strong,{children:"separate"}),", ",(0,s.jsx)(n.strong,{children:"isolated"})," lexical scope, which prevents it from accessing or modifying local variables or functions in the parent scope. This significantly mitigates security vulnerabilities."]}),"\n",(0,s.jsx)(n.p,{children:"Furthermore, the Trigger framework includes robust error handling to ensure that syntax errors or runtime exceptions within the dynamic logic do not crash the main application thread."}),"\n",(0,s.jsx)(n.h2,{id:"6-conclusion",children:"6. Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The Trigger class represents a robust and scalable solution for defining and managing application logic as data. Its dynamic hydration, coupled with a secure dependency injection pattern, empowers developers to build highly flexible, declarative systems that can be extended and modified at runtime without the need for code changes. This approach is ideal for applications requiring configurable business rules, a decoupled architecture, and real-time extensibility."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);