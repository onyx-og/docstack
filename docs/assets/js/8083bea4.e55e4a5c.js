"use strict";(self.webpackChunk_docstack_docs=self.webpackChunk_docstack_docs||[]).push([[8336],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},9952:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"architecture/data-model-propagation","title":"Structure and propagation","description":"Handling data model updates","source":"@site/docs/architecture/data-model-propagation.md","sourceDirName":"architecture","slug":"/architecture/data-model-propagation","permalink":"/docstack/docs/architecture/data-model-propagation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/architecture/data-model-propagation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Schemas System","permalink":"/docstack/docs/architecture/data-model-schema"},"next":{"title":"Triggers","permalink":"/docstack/docs/architecture/data-model-triggers"}}');var a=t(4848),i=t(8453);const r={},o="Structure and propagation",l={},d=[{value:"Handling data model updates",id:"handling-data-model-updates",level:2},{value:"Adding an attribute",id:"adding-an-attribute",level:3},{value:"Class data-model propagation",id:"class-data-model-propagation",level:3},{value:"Why a Web Worker is the Right Choice",id:"why-a-web-worker-is-the-right-choice",level:4},{value:"Understanding what&#39;s different",id:"understanding-whats-different",level:4},{value:"1. Offload All CPU-Intensive Tasks",id:"1-offload-all-cpu-intensive-tasks",level:5},{value:"2. Simplify the Main Thread&#39;s Role",id:"2-simplify-the-main-threads-role",level:5},{value:"3. Minimize Communication Overhead",id:"3-minimize-communication-overhead",level:5},{value:"Base Flow",id:"base-flow",level:4},{value:"Request queue",id:"request-queue",level:4},{value:"Complete Flow",id:"complete-flow",level:4}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"structure-and-propagation",children:"Structure and propagation"})}),"\n",(0,a.jsx)(n.h2,{id:"handling-data-model-updates",children:"Handling data model updates"}),"\n",(0,a.jsx)(n.h3,{id:"adding-an-attribute",children:"Adding an attribute"}),"\n",(0,a.jsx)(n.p,{children:"When a class is created, it has no attribute defined within its schema. In this scenario, adding an attribute involves:"}),"\n",(0,a.jsx)(n.h3,{id:"class-data-model-propagation",children:"Class data-model propagation"}),"\n",(0,a.jsxs)(n.p,{children:["When there are alredy documents belonging to a specific class (",(0,a.jsx)(n.code,{children:'type == "ClassA"'}),"), we expect that changes made to the class schema affects also the documents.\r\nTherefore, Stack during initialization sets up a listener that watches out for updates on Class documents."]}),"\n",(0,a.jsx)(n.p,{children:"In this scenario a Web Worker will handle the task of propagating the updates on documents belonging to the modified class, since it's:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Computationally Intensive: It involves querying a potentially large number of documents."}),"\n",(0,a.jsx)(n.li,{children:"I/O Bound: It requires reading data from the database and then writing it back."}),"\n",(0,a.jsx)(n.li,{children:"Not UI-Related: The task doesn't directly involve user interaction or rendering elements on the screen."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"why-a-web-worker-is-the-right-choice",children:"Why a Web Worker is the Right Choice"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Efficient Bulk Operations: A Web Worker is well-suited to perform the entire workflow:\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Querying for all documents of a specific class."}),"\n",(0,a.jsx)(n.li,{children:"Iterating through the results and applying the schema changes (adding, removing, or modifying properties)."}),"\n",(0,a.jsx)(n.li,{children:"Writing the updated documents back to the database using PouchDB's bulkDocs method for maximum efficiency."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Scalability: As the number of documents in a class grows, the time required for the update will increase. A Web Worker ensures that your application remains responsive regardless of the scale of the operation."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"understanding-whats-different",children:"Understanding what's different"}),"\n",(0,a.jsxs)(n.p,{children:["We use ",(0,a.jsx)(n.a,{href:"https://github.com/benjamine/jsondiffpatch",children:"jsondiffpatch"})," to differ and understand what changed in a datamodel. This information is useful to understand how it affects the documents.\r\nThe library produces a detailed patch object describing the changes between two JSON objects, including additions, removals, and modifications.\r\nThe ",(0,a.jsx)(n.code,{children:"jsondiffpatch"})," operation should be done ",(0,a.jsx)(n.strong,{children:"within the Web Worker"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Here's the reasoning from a developer's perspective, focusing on the architectural benefits and keeping your main thread responsive:"}),"\n",(0,a.jsx)(n.h5,{id:"1-offload-all-cpu-intensive-tasks",children:"1. Offload All CPU-Intensive Tasks"}),"\n",(0,a.jsxs)(n.p,{children:["The primary purpose of your Web Worker is to offload computationally heavy operations. The ",(0,a.jsx)(n.code,{children:"jsondiffpatch.diff()"})," function is a ",(0,a.jsx)(n.strong,{children:"synchronous"})," and ",(0,a.jsx)(n.strong,{children:"CPU-intensive"})," operation. If you were to perform this on the main thread, a very large schema could cause a brief but noticeable UI freeze."]}),"\n",(0,a.jsx)(n.p,{children:"By placing this logic inside the worker, you ensure that the entire, self-contained task\u2014from fetching the necessary revisions to performing the diff and finally executing the bulk update\u2014is handled on a separate thread."}),"\n",(0,a.jsx)(n.h5,{id:"2-simplify-the-main-threads-role",children:"2. Simplify the Main Thread's Role"}),"\n",(0,a.jsx)(n.p,{children:"The main thread's only job should be to act as a lightweight coordinator. Its task is to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Listen for a change event."}),"\n",(0,a.jsxs)(n.li,{children:["Send a simple, small message (",(0,a.jsx)(n.code,{children:"docId"}),", ",(0,a.jsx)(n.code,{children:"previousRevId"}),") to the worker."]}),"\n",(0,a.jsx)(n.li,{children:"React to the worker's completion message."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"It doesn't have to concern itself with the complex and potentially slow task of fetching document revisions or diffing them. This keeps the main thread responsive and the application's overall architecture clean and modular."}),"\n",(0,a.jsx)(n.h5,{id:"3-minimize-communication-overhead",children:"3. Minimize Communication Overhead"}),"\n",(0,a.jsxs)(n.p,{children:["Sending large objects between the main thread and a Web Worker (which involves serialization and deserialization) can be slow. By performing the diff ",(0,a.jsx)(n.em,{children:"inside"})," the worker, you only need to pass a minimal amount of data (",(0,a.jsx)(n.code,{children:"docId"}),", ",(0,a.jsx)(n.code,{children:"previousRevId"}),") once, at the beginning. If you performed the diff on the main thread, you would have to send the large, diffed object (",(0,a.jsx)(n.code,{children:"schemaDelta"}),") to the worker, which is less efficient."]}),"\n",(0,a.jsx)(n.h4,{id:"base-flow",children:"Base Flow"}),"\n",(0,a.jsx)(n.p,{children:"Here is a high-level overview:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Main Thread:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'The Stack has a PouchDB listener that only listens for changes on documents with type == "class". This listener is lightweight and fast.'}),"\n",(0,a.jsx)(n.li,{children:"When a class document is updated, the Stack will instantiate its member property modelWorker to the Web Worker instance."}),"\n",(0,a.jsxs)(n.li,{children:["It fetches the document information to understand what changed in the schema, by applying the following steps:\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Fetch the new document with the revisions list"}),"\n",(0,a.jsxs)(n.li,{children:["Use the second-last ",(0,a.jsx)(n.code,{children:"_rev"})," ID of to fetch the preciding version of the document"]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"jsondiffpatch"})," to compare the two documents and obtain the patch object to send alongside the workr message"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"It will then send a message to the Web Worker containing the necessary information, such as the className and the new schemas."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Web Worker Thread:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The Web Worker script (worker.js) will have its own instance of PouchDB. It's a separate environment"}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"It will have an onmessage event listener."}),"\n",(0,a.jsxs)(n.li,{children:["When a message is received from the main thread, the worker will:\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Query its PouchDB instance to find all documents belonging to that class"}),"\n",(0,a.jsx)(n.li,{children:"Perform the necessary modifications on the retrieved documents."}),"\n",(0,a.jsx)(n.li,{children:"Use db.bulkDocs() to write all the updated documents back to the database in a single, efficient call."}),"\n",(0,a.jsx)(n.li,{children:"Once the operation is complete, it will send a message back to the main thread to confirm completion or report an error."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Main Thread (again):"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The main thread listens for messages from the Web Worker."}),"\n",(0,a.jsx)(n.li,{children:'When a "success" message is received, the Stack will dispatch an event for the completion of the class-model-propagation.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["During this flow, Classes has their state that can be either at ",(0,a.jsx)(n.code,{children:"busy"})," or ",(0,a.jsx)(n.code,{children:"idle"}),'.\r\nWhen a class document is modified, the Stack sends a custom event "class-model-propagation-pending", which all classes listens to and, in the event where ',(0,a.jsx)(n.code,{children:"evt.detail.className"})," matches their class name, the class set's its member ",(0,a.jsx)(n.code,{children:"state"}),' to "busy". This prevents any further modification on its datamodel and having to manage race conditions.']}),"\n",(0,a.jsxs)(n.p,{children:['On completion of the bulk operation the Stack fires the event "class-model-propagation-complete", that causes Classes in object to set their member ',(0,a.jsx)(n.code,{children:"state"}),' back to "idle".']}),"\n",(0,a.jsx)(n.h4,{id:"request-queue",children:"Request queue"}),"\n",(0,a.jsx)(n.p,{children:"The queue is an architectural choice for a more robust and scalable application:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Prevents Database Contention:"})," While ",(0,a.jsx)(n.code,{children:"Class"}),"-level state prevents duplicate messages for a single class, it does ",(0,a.jsx)(n.strong,{children:"not"})," prevent simultaneous messages for ",(0,a.jsx)(n.em,{children:"different"})," classes. For example, if two different ",(0,a.jsx)(n.code,{children:"class"})," documents are updated at the same time, the ",(0,a.jsx)(n.code,{children:"Stack"})," would send two ",(0,a.jsx)(n.code,{children:"propagateSchema"})," messages to the worker. Without a queue, the worker would attempt to run two separate, parallel bulk database operations. This can lead to database contention and I/O bottlenecks, potentially slowing down both operations. The queue ensures that all database operations are handled sequentially, one at a time, preventing this issue."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Guarantees Execution Order:"}),' The queue provides a strict "first-in, first-out" (FIFO) guarantee. This ensures that if a change to "Class A" is detected before a change to "Class B", the bulk update for "Class A" will complete before the one for "Class B" begins. This predictability is crucial for debugging and maintaining a consistent data model over time.']}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Robustness and Future-Proofing:"})," The queue makes the worker more resilient to unexpected scenarios. If a future feature adds another type of long-running background task, you can simply send a new command to the worker. The queue will automatically handle the new task without needing to worry about it conflicting with a schema propagation. It\u2019s a valuable pattern for managing any asynchronous, multi-step process."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In summary, while ",(0,a.jsx)(n.code,{children:"Class"}),"-level state prevents duplicate ",(0,a.jsx)(n.strong,{children:"requests"}),", the worker's message queue prevents ",(0,a.jsx)(n.strong,{children:"concurrent execution"})," of bulk operations. Both mechanisms work together to create a robust, predictable, and scalable system."]}),"\n",(0,a.jsx)(n.h4,{id:"complete-flow",children:"Complete Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph TD\r\n    subgraph Main Thread [Stack]\r\n        A[PouchDB Listener] --\x3e|Change on class document| B(Send Message to Web Worker);\r\n        B --\x3e B2[Dispatch 'propagation-pending' Event];\r\n        L[Receive Message from Worker] --\x3e M{Status: success?};\r\n        M --\x3e|Yes| N[Dispatch 'propagation-complete' Event];\r\n        M --\x3e|No| O[Dispatch 'propagation-complete' Event with Error];\r\n    end\r\n\r\n    subgraph Web Worker\r\n        B --\x3e C{onmessage};\r\n        C --\x3e D[Add message to queue];\r\n        D --\x3e E{Call processQueue};\r\n        E --\x3e F{isProcessing?};\r\n        F --\x3e|No, Queue has items| G[Shift Message from Queue];\r\n        G --\x3e H[Query Documents by className];\r\n        H --\x3e I[Iterate and Apply Schema Changes];\r\n        I --\x3e J[Perform Bulk Update via db.bulkDocs];\r\n        J --\x3e K[Post Message with Status to Main Thread];\r\n        K --\x3e L;\r\n    end\r\n    \r\n    subgraph Class Instance\r\n        B2 --\x3e P[Listen for 'propagation-pending' event];\r\n        P --\x3e Q{Is evt.detail.className my class?};\r\n        Q --\x3e|Yes| R[Set state to 'busy'];\r\n        N --\x3e S[Listen for 'propagation-complete' event];\r\n        O --\x3e S;\r\n        S --\x3e T{Is evt.detail.className my class?};\r\n        T --\x3e|Yes| U[Set state to 'idle'];\r\n    end\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);