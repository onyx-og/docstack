"use strict";(self.webpackChunk_docstack_docs=self.webpackChunk_docstack_docs||[]).push([[2589],{8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>c});var n=s(6540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},8643:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"architecture/data-model-schema","title":"Schemas System","description":"This document provides a brief overview of the DocStack schema system, focusing on its functional purpose within the application\'s lifecycle.","source":"@site/docs/architecture/data-model-schema.md","sourceDirName":"architecture","slug":"/architecture/data-model-schema","permalink":"/docstack/docs/architecture/data-model-schema","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/architecture/data-model-schema.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Under the hood","permalink":"/docstack/docs/architecture/under-the-hood"},"next":{"title":"Structure and propagation","permalink":"/docstack/docs/architecture/data-model-propagation"}}');var a=s(4848),i=s(8453);const r={},c="Schemas System",o={},d=[{value:"The Schema Lifecycle: From Blueprint to Living Object",id:"the-schema-lifecycle-from-blueprint-to-living-object",level:2},{value:"1. The Raw Schema (The Stored Blueprint)",id:"1-the-raw-schema-the-stored-blueprint",level:3},{value:"2. The Hydrated Schema (The Living Blueprint)",id:"2-the-hydrated-schema-the-living-blueprint",level:3},{value:"The Validator: Ensuring Data Integrity",id:"the-validator-ensuring-data-integrity",level:2},{value:"Summary of Benefits",id:"summary-of-benefits",level:2},{value:"The DocStack Schema System: A Technical Overview",id:"the-docstack-schema-system-a-technical-overview",level:2},{value:"1. Architectural Overview",id:"1-architectural-overview",level:3},{value:"2. The Schema Data Model",id:"2-the-schema-data-model",level:3},{value:"3. The Hydration Process",id:"3-the-hydration-process",level:3},{value:"4. Validation and Run-time Usage",id:"4-validation-and-run-time-usage",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"schemas-system",children:"Schemas System"})}),"\n",(0,a.jsx)(t.p,{children:"This document provides a brief overview of the DocStack schema system, focusing on its functional purpose within the application's lifecycle."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["At its core, a schema is the ",(0,a.jsx)(t.strong,{children:"blueprint for a data object"}),". It's a set of rules and definitions that tells the system exactly what a specific class of data, like a ",(0,a.jsx)(t.code,{children:"User"})," or a ",(0,a.jsx)(t.code,{children:"Product"}),", should look like. This system ensures that all data flowing through our application is consistent, reliable, and free of errors."]}),"\n",(0,a.jsx)(t.h2,{id:"the-schema-lifecycle-from-blueprint-to-living-object",children:"The Schema Lifecycle: From Blueprint to Living Object"}),"\n",(0,a.jsx)(t.p,{children:"The schema follows a two-stage lifecycle:"}),"\n",(0,a.jsx)(t.h3,{id:"1-the-raw-schema-the-stored-blueprint",children:"1. The Raw Schema (The Stored Blueprint)"}),"\n",(0,a.jsxs)(t.p,{children:["This is the master copy of the schema. It's a simple, human-readable data structure stored in the database. It contains all the essential rules for each field of a class, such as its name, its basic type (",(0,a.jsx)(t.code,{children:"string"}),", ",(0,a.jsx)(t.code,{children:"number"}),", etc.), and a set of configuration rules (",(0,a.jsx)(t.code,{children:"mandatory"}),", ",(0,a.jsx)(t.code,{children:"maxLength"}),", etc.)."]}),"\n",(0,a.jsx)(t.p,{children:"This raw schema is the single source of truth for the entire application."}),"\n",(0,a.jsx)(t.h3,{id:"2-the-hydrated-schema-the-living-blueprint",children:"2. The Hydrated Schema (The Living Blueprint)"}),"\n",(0,a.jsxs)(t.p,{children:["When our application needs to actively work with a class, it doesn't use the raw data directly. Instead, a ",(0,a.jsx)(t.code,{children:"Class"}),' object is instantiated, and it takes the raw schema from the database and "hydrates" it.']}),"\n",(0,a.jsxs)(t.p,{children:["This hydration process transforms the static blueprint into a living, intelligent object. This new object contains all the business logic and, most importantly, the ",(0,a.jsx)(t.strong,{children:"automated validation rules"})," that are ready to be used."]}),"\n",(0,a.jsx)(t.h2,{id:"the-validator-ensuring-data-integrity",children:"The Validator: Ensuring Data Integrity"}),"\n",(0,a.jsxs)(t.p,{children:["The primary purpose of the hydrated schema is to act as a powerful ",(0,a.jsx)(t.strong,{children:"data validator"}),". Every time new data is created or an existing record is updated, the validator automatically inspects it against the schema's rules. This inspection is far more than a simple check:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Type & Format Checks:"})," The validator confirms that each field has the correct data type (e.g., ",(0,a.jsx)(t.code,{children:"username"})," is a ",(0,a.jsx)(t.code,{children:"string"}),", ",(0,a.jsx)(t.code,{children:"age"})," is a ",(0,a.jsx)(t.code,{children:"number"}),")."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rule Enforcement:"})," It checks that fields meet specific business requirements, such as a password having a minimum length or a field not exceeding a maximum length."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Data Integrity Checks:"}),' The validator can even verify that a field referencing another document (a "foreign key") actually points to an existing document in the database. This prevents broken links and ensures our data is always connected correctly.']}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"summary-of-benefits",children:"Summary of Benefits"}),"\n",(0,a.jsx)(t.p,{children:"This schema system brings significant functional benefits:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Data Consistency:"})," By automatically enforcing a single set of rules, it ensures all data adheres to the same standards."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Error Prevention:"})," The validation layer acts as a safety net, catching common data entry mistakes before they can be saved to the database."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Business Reliability:"})," We can trust that any data processed by the application is valid and correct, allowing us to build a more robust and reliable system."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"the-docstack-schema-system-a-technical-overview",children:"The DocStack Schema System: A Technical Overview"}),"\n",(0,a.jsx)(t.p,{children:"This document provides a technical overview of the DocStack schema system, detailing its architectural design, data models, and the run-time processes that ensure data integrity."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h3,{id:"1-architectural-overview",children:"1. Architectural Overview"}),"\n",(0,a.jsxs)(t.p,{children:["The schema system is built on a ",(0,a.jsx)(t.strong,{children:"schema-driven design pattern"}),", establishing a clear separation of concerns between data definition and data validation. The central principle is to maintain a single source of truth for all data models, which is then programmatically used to generate robust validation and provide compile-time type safety."]}),"\n",(0,a.jsxs)(t.p,{children:["The system relies on a two-stage lifecycle: a persisted ",(0,a.jsx)(t.strong,{children:"raw schema data model"})," and a dynamically generated ",(0,a.jsx)(t.strong,{children:"hydrated Zod schema instance"})," at run-time."]}),"\n",(0,a.jsx)(t.h3,{id:"2-the-schema-data-model",children:"2. The Schema Data Model"}),"\n",(0,a.jsxs)(t.p,{children:["The schema for a ",(0,a.jsx)(t.code,{children:"Class"})," is defined and persisted in a structured JSON format. This model represents the complete definition of a data object and its attributes."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Core Interfaces:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"ClassModel"}),": The top-level data model for a class.\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"interface ClassModel {\r\n  _id: string;\r\n  name: string;\r\n  description?: string;\r\n  type: 'class';\r\n  schema: { [name: string]: AttributeModel };\r\n  // ... other metadata\r\n}\n"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"AttributeModel"}),": The data model for a single field or attribute within a class's schema.\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"interface AttributeModel {\r\n  type: 'string' | 'number' | 'boolean' | 'date' | 'foreign_key';\r\n  config: {\r\n    primaryKey?: boolean;\r\n    maxLength?: number;\r\n    mandatory?: boolean;\r\n    isArray?: boolean;\r\n    foreignKeyClass?: string;\r\n  };\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"type"})," field in ",(0,a.jsx)(t.code,{children:"AttributeModel"})," explicitly defines the attribute's data type, while the ",(0,a.jsx)(t.code,{children:"config"})," object serves as a container for all validation flags and parameters. The ",(0,a.jsx)(t.code,{children:"foreign_key"})," type is a special case that triggers an asynchronous validation routine."]}),"\n",(0,a.jsx)(t.h3,{id:"3-the-hydration-process",children:"3. The Hydration Process"}),"\n",(0,a.jsxs)(t.p,{children:["The hydration process is executed within the ",(0,a.jsx)(t.code,{children:"Class"})," instance's constructor. Its purpose is to transform the static ",(0,a.jsx)(t.code,{children:"ClassModel.schema"})," into a living ",(0,a.jsx)(t.code,{children:"z.ZodObject"})," that can be used for direct validation. This logic is encapsulated within a private method, ",(0,a.jsx)(t.code,{children:"hydrateSchema()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Hydration Logic:"}),"\r\nThe ",(0,a.jsx)(t.code,{children:"hydrateSchema()"})," method performs the following steps:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Dynamic Schema Mapping:"})," It iterates over each attribute defined in the ",(0,a.jsx)(t.code,{children:"ClassModel.schema"}),". For each attribute, it uses a ",(0,a.jsx)(t.code,{children:"switch"})," statement on the ",(0,a.jsx)(t.code,{children:"attribute.type"})," to dynamically instantiate the corresponding base Zod schema (",(0,a.jsx)(t.code,{children:"z.string()"}),", ",(0,a.jsx)(t.code,{children:"z.number()"}),", ",(0,a.jsx)(t.code,{children:"z.boolean()"}),", etc.)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Validation Rule Chaining:"})," It then programmatically chains Zod's refinement and validation methods based on the ",(0,a.jsx)(t.code,{children:"attribute.config"})," properties. For example, ",(0,a.jsx)(t.code,{children:"maxLength"})," is mapped to ",(0,a.jsx)(t.code,{children:".max()"}),", and non-mandatory fields are mapped to ",(0,a.jsx)(t.code,{children:".optional()"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Asynchronous Refinement:"})," For the ",(0,a.jsx)(t.code,{children:"foreign_key"})," type, an asynchronous ",(0,a.jsx)(t.code,{children:".refine()"})," method is applied. This method is passed a database connection and uses ",(0,a.jsx)(t.code,{children:"Promise.all"})," to concurrently verify the existence of all specified document IDs in the referenced collection. This crucial step prevents invalid cross-document references."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Final Object Construction:"})," After processing all attributes, the method constructs and returns a single ",(0,a.jsx)(t.code,{children:"z.object()"})," that contains all the dynamically generated fields, each with its type and validation rules configured."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The final result is stored in the ",(0,a.jsx)(t.code,{children:"this.schema"})," property of the ",(0,a.jsx)(t.code,{children:"Class"})," instance."]}),"\n",(0,a.jsx)(t.h3,{id:"4-validation-and-run-time-usage",children:"4. Validation and Run-time Usage"}),"\n",(0,a.jsxs)(t.p,{children:["Once a ",(0,a.jsx)(t.code,{children:"Class"})," instance has been created, its ",(0,a.jsx)(t.code,{children:"schema"})," property is a ready-to-use Zod object."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Validation API:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsxs)(t.strong,{children:[(0,a.jsx)(t.code,{children:".parse(data)"}),":"]})," Used for synchronous validation of an object against the schema. It will throw a ",(0,a.jsx)(t.code,{children:"ZodError"})," if validation fails. This method is suitable for all fields except ",(0,a.jsx)(t.code,{children:"foreign_key"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsxs)(t.strong,{children:[(0,a.jsx)(t.code,{children:".parseAsync(data)"}),":"]})," ",(0,a.jsx)(t.strong,{children:"Must be used"})," for any validation that includes ",(0,a.jsx)(t.code,{children:"foreign_key"})," fields. This method returns a promise that resolves on successful validation or rejects with a ",(0,a.jsx)(t.code,{children:"ZodError"})," on failure."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Type Safety:"}),"\r\nThe hydrated Zod schema serves as a single source of truth for both run-time validation and compile-time type safety. Developers can use Zod's ",(0,a.jsx)(t.code,{children:"z.infer"})," utility to extract a type from the hydrated schema, ensuring that their code is fully type-safe and consistent with the database model."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"// Get a type-safe interface for the User class\r\ntype UserType = z.infer<typeof userClass.schema>;\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);